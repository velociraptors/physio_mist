#include "ClassBuilder.h"



//class builder.
ClassBuilder::ClassBuilder() 
{
	//constructor
}

/*Constructor: opens file to parse and loads a slot resource file.*/
ClassBuilder::ClassBuilder(char *protegeFileName, char *slotResource) 
{
	PParser.openFileToParse(protegeFileName);	//opens the protege source file.
	SlotArray.loadSlots(slotResource);			//loads the slot definitions.
}


//Opens the output file.
//Reads the syntax tree generated by the parser. Using the tree, C++ code is generated.
void ClassBuilder::buildToFiles(const char *directory) 
{
	char fileName[MAX_PATH_LEN] = "";		//A temporary var to hold a string.
	char cppFileName[MAX_PATH_LEN] = "";	//Contains .cpp file name.
	char hFileName[MAX_PATH_LEN] = "";		//.h file name
	
	BigClassObject	*classdata = NULL;		//classData contains data for a class.


	while (true)		
	{
		/*Each iteration of this loop generates one class.*/
		classdata = PParser.parseClass ();		//Get the next class. This method may need changing, in case you want to parse a different type of file.
		//classdata - PParser.parseProtegeFile(); //other type of parsing.
		if (classdata == NULL)	break;			//if there are no more classes, break out of loop.

		
		/*Get class name and it's parent's name.*/
		char *className = classdata->getClassName ();		//retrieve class name
		char *classIsA = classdata->getClassParent ();		//retrive class parent
		//char *classIsA = "Organ";		//Cutoff point at "Organ"? May change later. (2/4/2008), commeneted on (2/13/2008)
		//bool singletonClass = classdata->getSingletonStatus ();	//retrive class's singleton status (true or false)
		bool singletonClass = false; //make this FALSE if you don't want SINGLETON!!
		bool	classIsRoot = false;						//Is this class the root class?
		if (strcmp(classIsA,"USER") == 0)	classIsRoot = true;	//If the parent is "USER", then this class is the root.

		strncpy(fileName,directory,MAX_PATH_LEN);			//Configure the file name using a series of string manips.
		strncat(fileName,"\\",MAX_PATH_LEN);
		strncat(fileName,className,MAX_PATH_LEN);
		strncpy(cppFileName,fileName,MAX_PATH_LEN);
		strncpy(hFileName,fileName,MAX_PATH_LEN);
		strncat(hFileName,".h",MAX_PATH_LEN);			//create the directory and file name
		strncat(cppFileName,".cpp",MAX_PATH_LEN);		//

		outHFile.open (hFileName);		//opens the .h file
		outCppFile.open (cppFileName);	//opens the .cpp file
		
										//begin writing to the HEADER file.
		
		
		/*Preprocessor. Headers, comments and macros.*/
		outHFile << "//////////////////////////////////////////////////////" << endl;
		outHFile << "// " << className << endl;
		outHFile << "//////////////////////////////////////////////////////" << endl;

		outCppFile << "//////////////////////////////////////////////////////" << endl;
		outCppFile << "// Implementation of " << className << endl;
		outCppFile << "//////////////////////////////////////////////////////" << endl;
		outCppFile << "#include \"" << className << ".h\"" << endl;	//Include the header file which contains class declaration.

		outHFile << "#ifndef CLASS_" << className << endl;			//Macros to prevent redeclaration.
		outHFile << "#define CLASS_" << className << endl <<endl;

							//Include parent class.
		if (!classIsRoot)
			outHFile << "#include \"" << classIsA << ".h\"" << endl<<endl;

		if (classIsRoot)
		{
			/*Includes <cstring> library for the root class.*/
			outHFile << "#include <cstring>" << endl;
			outHFile << "#include \"utilities.h\"" << endl;
			outHFile << "#include \"symbolDefs.h\"" << endl;
		}

		/*Begin class declaration in header*/
		outHFile << "class " << className;

		if ( !classIsRoot )
		{
			/*Defines inheritance, as long as the parent is a different class.*/
			outHFile << ": public " << classdata->getClassParent ();
		}
	
		
		outHFile << "\n{\npublic:\n\t";		//print out public members.
		//This conditional decides if the class should be defined singleton or not.
		if (singletonClass == true)
			outHFile << "static " << className << " *getInstance();\n"; //singleton method
		else
			//public Constructor.
			outHFile << className << "();\n";
		

		buildGetSetMethods(classdata);	//writes out get/set methods in the H file and CPP file.
		

		outHFile << "protected:\n\t";			//print out protected members.
	
		if (singletonClass == true)
		{
			//protected constructor, if class is defined to be singleton.
			outHFile	<< className << "();\n";	
			//Singleton instance variable.
			outHFile << "\tstatic " << className << "* instance;\n";
		}

		//Defines constructor in the .cpp file.
		outCppFile << className << "::" << className << "()\n{\n";

		buildSlots(classdata);					//print out private member slots.
											//also builds the constructor (this is done in the buildSlots function).
		outCppFile << "}\n\n";			//end constructor definition.
		
		
		outHFile << "};" << endl << endl;	//print out end of class.
		outHFile << "#endif";		
		
		//WE are done with the header file at this point.

		//Singleton method definition in the .cpp file.
		if (singletonClass == true)
		{
			outCppFile << className << "*" << className << "::instance = NULL;\n\n";
			outCppFile << className << "* " << className << "::getInstance()\n{\n\t";
			outCppFile << "if (instance == NULL) \n \t\tinstance = new " << className << "();\n";
			outCppFile << "\telse\n \t\treturn instance;\n}\n";
		}

		cout << "Parsed to file: " << hFileName << endl;
		outHFile.close ();					//close file
		outCppFile.close();
		
		delete	classdata;	//deletes the BigClassObject data structure to free memory.
		/*I do this because each time I call parseClass(), a new BigClassObject is generated. 
		The old one will still be somewhere in memory, unreferenced.*/
		classdata = NULL;
	}//end while loop

	writeEnumDefs(directory);		//write enum defs to file.

	PParser.closeFile();	//closes the protege file.
	cout << "Finished parsing all classes from the .pins file" << endl;
}

void ClassBuilder::buildGetSetMethods (BigClassObject *bco)
{
	bco->resetSlotCursor ();
	SlotData *cursor = bco->getNextSlot ();

	if ( cursor != NULL )
	{
		//move cursor to the right of the root.
		while(true)
		{
		
			char *slotName = cursor->getSlotName ();	//get slot name
			char *slotType = SlotArray.getSlotType (slotName);	//get slot type
			char *className = bco->getClassName ();
			bool slotHasPointer = SlotArray.slotHasPointer (slotName);	//is the slot an object? that means it should be a pointer.
			bool slotNeedsList = slotUsesList(cursor);					//can the slot hold more than one value? then it should be in a list container.
			bool slotIsChar = false;
			if ( strcmp(slotType,"char") == 0)	slotIsChar = true;
			if (outHFile.is_open ())
			{

				char * tabSpace = "\t\t\t";
				outHFile << endl;
				outHFile << "\t";				//output tab.
				outHFile << "void " << tabSpace;		//Set method.

				outCppFile << endl;
				outCppFile << "void " << className << "::";

				if (slotNeedsList)
				{
					outHFile << "add_";
					outCppFile << "add_";
				}
				else
				{
					outHFile << "set_";
					outCppFile << "set_";
				}

				outHFile << slotName << "( ";
				outCppFile << slotName << "( ";
				outHFile << slotType;
				outCppFile << slotType;
				if ( slotHasPointer || slotIsChar) 
				{
					outHFile << "*";	//output pointer symbol.
					outCppFile << "*";
				}
				outHFile << " n" << slotName << " );\n";
				outCppFile << " n" << slotName << " )\n{\n\t"; //Implementation of Set Method.
				if ( slotIsChar)
				{
					outCppFile << "strcpy( " << slotName << ", n" << slotName << ");";
				}
				else if ( slotNeedsList )
				{
					outCppFile << slotName << ".addItem( n" << slotName << ");";
				}
				else
				{
					outCppFile << slotName << " = n" << slotName << ";";
				}
				outCppFile << "\n}\n";

												
												
				
				outHFile << "\t";				//Get method.
				outHFile << slotType;

				outCppFile << slotType;
				if ( slotHasPointer || slotIsChar)
				{
					outHFile << "*";	//pointer
					outCppFile << "*";
				}
				outHFile << tabSpace;
				outCppFile << " ";
				outCppFile << className << "::";
				if (slotNeedsList)
				{
					outHFile << " getNext_" << slotName << "();\n";
					outCppFile << "getNext_" << slotName << "()\n{\n\t";
					outCppFile << "return " << slotName << ".getNextItem();\n}\n";
					

					outHFile << "\tvoid" << tabSpace << "reset_" << slotName << "();\n";
					outCppFile << "void " << className << "::" << "reset_" << slotName << "()\n{\n\t";
					outCppFile << slotName << ".resetCursor();\n}\n";
				}
				else
				{
					outHFile << " get_" << slotName << "();\n";
					outCppFile << "get_" << slotName << "()\n{\n\t";
					outCppFile << "return " << slotName << ";\n}\n";
				}

				cursor = bco->getNextSlot ();	//get the next slot.
				if (cursor == NULL)	break;		//if there are no more slots, break out of loop.
			}
		}	//end while
	}	//end if
}		//end build slots


//The function also writes to the constructor function.
void ClassBuilder::buildSlots (BigClassObject	*bco)
{
	bco->resetSlotCursor ();
	SlotData * cursor = bco->getNextSlot ();

	if ( cursor != NULL )
	{
		//move cursor to the right of the root.
		while(true)
		{
		
			char *slotName = cursor->getSlotName ();	//get slot name
			char *slotType = SlotArray.getSlotType (slotName);	//get slot type
			bool slotHasPointer = SlotArray.slotHasPointer (slotName);	//is the slot an object? that means it should be a pointer.
			bool slotNeedsList = slotUsesList(cursor);					//can the slot hold more than one value? then it should be in a list container.
			if (outHFile.is_open ())
			{

				//Commented out on 2/4/2008, due to changes. On 2/13/2008, uncommented this section.
				outHFile << "\t";				//output tab.


				if ( slotNeedsList) outHFile << "Container<" << slotType << ">\t";	//prints out ListContainer if a slot can have more than one value.
				else	outHFile  << slotType << "\t";


				if ( slotHasPointer && !slotNeedsList ) outHFile << "*";			//prints out pointer symbol if needed.
				outHFile << slotName;								//variable name (slot name)
				if ( strcmp(slotType,"char") == 0) outHFile << "[255]";	//prints out special char[] if needed for strings.
				outHFile << ";" << endl;					//end semi colon.
				
				/*For now, lets not build the constructor.*/
				//buildConstructor(cursor);					//writes the constructor.
			}

			cursor = bco->getNextSlot ();	//cursor points to next slot data struct.
			if (cursor == NULL)	break;		//if there are no more slots, break out of loop.
		}	//end while
	}	//end if
}		//end build slots

//Writes the constructor in the CPP file.
void ClassBuilder::buildConstructor(SlotData *sd) 
{
	sd->resetSlotValuesCursor ();
	char slotValue[MAX_TOKEN_LEN];
	strncpy(slotValue,sd->getNextSlotValue (),MAX_TOKEN_LEN);

	if ( strcmp(slotValue,"") != 0 )
	{
		char *slotName = sd->getSlotName ();
		char *slotType = SlotArray.getSlotType (slotName);
		bool slotNeedsList = slotUsesList(sd);
		bool slotHasPointer = SlotArray.slotHasPointer (slotName);
		if (outCppFile.is_open () )	//if the CPP file is open, write the constructor to it.
		{
			if ( !slotNeedsList)
			{
				outCppFile << "\tset_" << slotName << "(";
				outCppFile << slotValue;
				if (slotHasPointer)  outCppFile << "::Instance()";
				outCppFile << ");\n";
			
			}
			else
			{
				while (true)
				{
					outCppFile << "\tadd_" << slotName << "(";
					 outCppFile << slotValue;
					if (slotHasPointer)  outCppFile << "::Instance()";
					outCppFile << ");\n";

					strncpy(slotValue,sd->getNextSlotValue (),MAX_TOKEN_LEN);
					if (strcmp(slotValue,"") == 0) break;
				}
			}		
		}			//end if outCppFile is open
	}				//end if cursor!NULL
}					//end class (Build constructor)

//determines if a slot holds more than one value.
bool ClassBuilder::slotUsesList(SlotData *sd) 
{
	/*
	int itemCount = sd->getValueCount ();
	bool	returnvalue = false;

	if (itemCount <= 1)
		returnvalue = false;
	else
		returnvalue = true;
	
	

	return returnvalue;
	*/
	if (strcmp(SlotArray.getSlotType (sd->getSlotName()),SlotArray.getSlotType("DefaultClass"))==0) return true;
	else return false;
}



//writes enum defs to another file.
void ClassBuilder::writeEnumDefs(const char *directory) 
{
	char directoryTemp[255];
	strcpy(directoryTemp,directory);
	char *hFileNameEnum = strcat(directoryTemp,"\\symbolDefs.h");
	//put enum defs list here.


	ofstream outFileEnum;
	outFileEnum.open(hFileNameEnum);
	outFileEnum << "///////////////////////////////////////////////\n";
	outFileEnum << "// Enum (Symbol) Definitions\n";
	outFileEnum << "///////////////////////////////////////////////\n";
	outFileEnum << "#ifndef ENUM_DEFS\n";
	outFileEnum << "#define ENUM_DEFS\n";

	ifstream inputFile;
	inputFile.open("enumConfig.inf");
	char lineBuffer[MAX_PATH_LEN];
	char *delimiter = "+;";

	while ( strcmp(lineBuffer,delimiter) != 0)	inputFile.getline(lineBuffer,MAX_PATH_LEN); //skip opening comments.

	while ( !inputFile.eof()  )
	{
		inputFile.getline(lineBuffer,MAX_PATH_LEN);
		outFileEnum << lineBuffer << endl;

	}
	
	outFileEnum << "#endif";
	inputFile.close();
	outFileEnum.close();
}

/*This function checks if two strings are the same.*/
bool	ClassBuilder::classIsSameAsParent(const char *className, const char *classParent) 
{
	if ( strcmp(className,classParent) == 0)
		return true;
	else
		return false;
}